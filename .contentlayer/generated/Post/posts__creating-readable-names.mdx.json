{
  "title": "Creating readable names",
  "date": "2021-01-14T00:00:00.000Z",
  "description": "I have seen a proliferation of easy meaningless words that look like documentation but explain very l...",
  "tags": [
    "beginners",
    "codequality",
    "javascript"
  ],
  "coverImage": "/images/blog/creating-readable-names.jpeg",
  "body": {
    "raw": "\n\nI have seen a proliferation of easy meaningless words that look like documentation but explain very little. Naming is one of our most challenging problems. The importance of meaningful names cannot be overstated and should not be an afterthought. Attention to naming increases code readability and trust. Well-named methods and variables are more likely to be reused, and creating reusable code is the purpose of creating shared libraries.\n\n## Combining words\n\n* **Camel**: (camelCase)\n* **Kebab**: (kebab-case)\n* **Pascal**: (PascalCase)\n* **Snake**: (snake_case)\n* **Screaming Snake**: (SCREAMING_SNAKE_CASE)\n\nEach language has its preferred cases for various things. Always follow the lining standards for your language. I use JavaScript and Python so here are those.\n\n### Javascript\n\n* **Camel**: variables, methods, and functions\n* **Pascal**: types, classes, and constructors\n* **Screaming Snake Case**: global immutable constants\n\n### Python\n\n* **Snake Case**: variables, methods, and functions\n* **Pascal**: types, classes, and constructors\n* **Screaming Snake Case**: global immutable constants\n\n## Meaningless words:\n\nNever use the following words. They add no meaning to the name and can always be replaced with a better, more specific term.\n\n* code\n* data\n* meta\n* mutate\n* parse\n* payload\n* transform\n* util\n\nConsider the difference between two methods called **getArticle** and **getArticleData**. As an outsider reading that API, if there is nothing else known about those methods, it would be very difficult to know which one to use in each situation. The word **data** is adding no information.\n\nOne could say that people should just read the documentation if they want to know the method details. **getArticleData** becomes tough to understand when nested within other functions.\n\nFor example:\n\n```JavaScript\nfunction getAuthors(id) {\n  const data = service.getArticleData(id);\n  const article = service.getArticle(id);\n  return article.getAuthors(data);\n}\n```\n\nAlthough we can see this method is supposed to get the authors of an article, the internal logic is difficult to read because it is unclear what the internal methods do. The word Data doesn't add enough meaning to warrant, adding it to the name.\n\nConsider the difference between the three methods __mutate__, __transform__, and __parse__. Having not read the implementation of those methods, you can not know the convention for what these words mean within the context of the project. It is challenging to see the purpose of those methods or the order in which they should be used.\n\nFor example:\n\n```JavaScript\nfunction getArticle(uri) {\n  return Article.fetch(uri)\n    .then(mutateAuthors)\n    .then(parseAuthors) // bug: authors should have been parsed before being mutated\n    .then(transform);\n}\n```\n\nAlthough it is evident that this method gets an article (of some unknown state and type), finding bugs with the ordering or functionality of this method is impossible without resorting to debugger statements or console logs. It is forcing the developer to run the code to understand the expected values between each step.\n\n## Obfuscation\n\nWhen the purpose of the function or variable name is to hide or limit understanding (i.e., black boxes, facades, moderators), then obviously this does not apply. The words referred to here as having low informational value may be useful in those cases where we're deliberately trying to hide.\n\nFor example:\n\n```JavaScript\nreturn getArticle()\n  .then(applyTransformations(options));\n```\n\nIn this case, we're deliberately hiding what the transformations are behind a layer of obfuscation or abstraction. There are many reasons this is valuable, including preserving the right to change the contents of the functionality in the future dramatically.\n\n## Acronyms, Initialism, Abbreviations, and Disemvoweling\n\nShortened words are a constant source of confusion. It is generally better to enter the full name and not the abbreviation, but there are cases where it would be redundant to do so, as in the case of well-known acronyms like AMP or HTML. In this case, stick to the camel case and only capitalize the first letter of the acronym, especially when the initialism is beginning.\n\n## Single Characters\n\nSingle-character names should be avoided, even within a loop where the temptation to use an “I” for the iterator.  Think of the group you are looping over. Doesn’t the following make a lot more sense?\n\n```Javascript\nfor (const dog in dogs) {\n  console.log(`${dog}: ${dogs[dog]}`);\n}\n```\n\n## Better Verbs:\n\n* **get**: Retrieve some state.\n* **set**: Change some state.\n* **reset**: Reset some state to its default value.\n* **add**: Add new content to some state.\n* **remove**: Delete some existing state.\n* **apply**: In-memory replacements\n* **compose**: Create a new dataset from existing information.\n* **fetch**:  Retrieve some state from an external data store.\n* **handle**: Deal with an action.  Often used in callbacks.\n* **is/has**: A pre-verb to denote a boolean.\n* **$**: A pre-verb to indicate a JQuery reference.\n\n## Duplication\n\nAny named item that is a child should not duplicate its parent name, nor should it repeat any synonym of that patents name. In the following example, we see breakpoints.  We know that breakpoints refer to widths, and as our project is mobile-first, we know they are all minimum widths.\n\n**BAD**\n```JavaScript\n$breakpoints = {\n  minWidthLg: “1440px”,\n  minWidthMd: “1200px”,\n  minWidthSm: “992px”,\n  minWidthXs: “768px”,\n  minWidthXxs: “500px”\n};\n```\n\n**GOOD**\n```JavaScript\n$breakpoints = {\n    xl: “1440px”,\n    lg: “1200px”,\n    md: “992px”,\n    sm: “768px”,\n    xs: “500px”\n};\n```\n\n## Classes\n\nClasses must be named with an appropriate proper singular noun in PascalCase, and tell us that this variable contains a type with properties and methods.\n\n```JavaScript\nclass Animal { }\nclass Dog extends Animal { }\nclass Dachshunds extends Dog { }\n```\n\n## Class Methods and properties\n\nClass methods and properties use the verb + noun convention, but the methods can get away with omitting the noun in some cases.  In this case, the noun is the parent class.  User.get() assumes you are getting the user User.name assumes a user name.\n\n```JavaScript\nDog.getName()\nDog.setColor()\nDog.wagTail()\n```\n\n## Numbers, Strings, and Objects\n\nName all Numbers, strings, and objects with the most appropriate singular noun.\n\n## Booleans\n\nThe names for booleans are in the form of a question, asking what it is or has or can be.  So our verbs are: is, has, can, or will.\n\n## Arrays\n\nName arrays with a plural noun, allowing us to address each child as a singular noun.  If need be, you can replace plural with a collection name birds becomes **flockOfBirds**.\n\n## Functions\n\nFunctions are always actions. So we start with a verb then add a noun. Verb + Noun results in a command for a thing. \n\n```JavaScript\ngetBirds();\ngoHome()\n```\n\nSome languages have their own rules around specific types of things (TypeScript prefers interfaces begin with a capital I). I am mostly interested in language-agnostic naming. Do you have any preferences around naming? Bring them up in the comments, and let’s discuss!\n",
    "code": "var Component=(()=>{var d=Object.create;var r=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var f=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),b=(t,e)=>{for(var a in e)r(t,a,{get:e[a],enumerable:!0})},o=(t,e,a,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of u(e))!p.call(t,i)&&i!==a&&r(t,i,{get:()=>e[i],enumerable:!(s=g(e,i))||s.enumerable});return t};var w=(t,e,a)=>(a=t!=null?d(m(t)):{},o(e||!t||!t.__esModule?r(a,\"default\",{value:t,enumerable:!0}):a,t)),y=t=>o(r({},\"__esModule\",{value:!0}),t);var h=f((C,l)=>{l.exports=_jsx_runtime});var A={};b(A,{default:()=>k,frontmatter:()=>v});var n=w(h()),v={title:\"Creating readable names\",date:\"2021-01-14\",description:\"I have seen a proliferation of easy meaningless words that look like documentation but explain very l...\",tags:[\"beginners\",\"codequality\",\"javascript\"],coverImage:\"/images/blog/creating-readable-names.jpeg\"};function c(t){let e=Object.assign({p:\"p\",h2:\"h2\",ul:\"ul\",li:\"li\",strong:\"strong\",h3:\"h3\",pre:\"pre\",code:\"code\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"I have seen a proliferation of easy meaningless words that look like documentation but explain very little. Naming is one of our most challenging problems. The importance of meaningful names cannot be overstated and should not be an afterthought. Attention to naming increases code readability and trust. Well-named methods and variables are more likely to be reused, and creating reusable code is the purpose of creating shared libraries.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Combining words\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Camel\"}),\": (camelCase)\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Kebab\"}),\": (kebab-case)\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Pascal\"}),\": (PascalCase)\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Snake\"}),\": (snake_case)\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Screaming Snake\"}),\": (SCREAMING_SNAKE_CASE)\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Each language has its preferred cases for various things. Always follow the lining standards for your language. I use JavaScript and Python so here are those.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Javascript\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Camel\"}),\": variables, methods, and functions\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Pascal\"}),\": types, classes, and constructors\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Screaming Snake Case\"}),\": global immutable constants\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Python\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Snake Case\"}),\": variables, methods, and functions\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Pascal\"}),\": types, classes, and constructors\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Screaming Snake Case\"}),\": global immutable constants\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Meaningless words:\"}),`\n`,(0,n.jsx)(e.p,{children:\"Never use the following words. They add no meaning to the name and can always be replaced with a better, more specific term.\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"code\"}),`\n`,(0,n.jsx)(e.li,{children:\"data\"}),`\n`,(0,n.jsx)(e.li,{children:\"meta\"}),`\n`,(0,n.jsx)(e.li,{children:\"mutate\"}),`\n`,(0,n.jsx)(e.li,{children:\"parse\"}),`\n`,(0,n.jsx)(e.li,{children:\"payload\"}),`\n`,(0,n.jsx)(e.li,{children:\"transform\"}),`\n`,(0,n.jsx)(e.li,{children:\"util\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Consider the difference between two methods called \",(0,n.jsx)(e.strong,{children:\"getArticle\"}),\" and \",(0,n.jsx)(e.strong,{children:\"getArticleData\"}),\". As an outsider reading that API, if there is nothing else known about those methods, it would be very difficult to know which one to use in each situation. The word \",(0,n.jsx)(e.strong,{children:\"data\"}),\" is adding no information.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"One could say that people should just read the documentation if they want to know the method details. \",(0,n.jsx)(e.strong,{children:\"getArticleData\"}),\" becomes tough to understand when nested within other functions.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"For example:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-JavaScript\",children:`function getAuthors(id) {\n  const data = service.getArticleData(id);\n  const article = service.getArticle(id);\n  return article.getAuthors(data);\n}\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Although we can see this method is supposed to get the authors of an article, the internal logic is difficult to read because it is unclear what the internal methods do. The word Data doesn't add enough meaning to warrant, adding it to the name.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Consider the difference between the three methods \",(0,n.jsx)(e.strong,{children:\"mutate\"}),\", \",(0,n.jsx)(e.strong,{children:\"transform\"}),\", and \",(0,n.jsx)(e.strong,{children:\"parse\"}),\". Having not read the implementation of those methods, you can not know the convention for what these words mean within the context of the project. It is challenging to see the purpose of those methods or the order in which they should be used.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"For example:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-JavaScript\",children:`function getArticle(uri) {\n  return Article.fetch(uri)\n    .then(mutateAuthors)\n    .then(parseAuthors) // bug: authors should have been parsed before being mutated\n    .then(transform);\n}\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Although it is evident that this method gets an article (of some unknown state and type), finding bugs with the ordering or functionality of this method is impossible without resorting to debugger statements or console logs. It is forcing the developer to run the code to understand the expected values between each step.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Obfuscation\"}),`\n`,(0,n.jsx)(e.p,{children:\"When the purpose of the function or variable name is to hide or limit understanding (i.e., black boxes, facades, moderators), then obviously this does not apply. The words referred to here as having low informational value may be useful in those cases where we're deliberately trying to hide.\"}),`\n`,(0,n.jsx)(e.p,{children:\"For example:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-JavaScript\",children:`return getArticle()\n  .then(applyTransformations(options));\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"In this case, we're deliberately hiding what the transformations are behind a layer of obfuscation or abstraction. There are many reasons this is valuable, including preserving the right to change the contents of the functionality in the future dramatically.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Acronyms, Initialism, Abbreviations, and Disemvoweling\"}),`\n`,(0,n.jsx)(e.p,{children:\"Shortened words are a constant source of confusion. It is generally better to enter the full name and not the abbreviation, but there are cases where it would be redundant to do so, as in the case of well-known acronyms like AMP or HTML. In this case, stick to the camel case and only capitalize the first letter of the acronym, especially when the initialism is beginning.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Single Characters\"}),`\n`,(0,n.jsx)(e.p,{children:\"Single-character names should be avoided, even within a loop where the temptation to use an \\u201CI\\u201D for the iterator.  Think of the group you are looping over. Doesn\\u2019t the following make a lot more sense?\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-Javascript\",children:\"for (const dog in dogs) {\\n  console.log(`${dog}: ${dogs[dog]}`);\\n}\\n\"})}),`\n`,(0,n.jsx)(e.h2,{children:\"Better Verbs:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"get\"}),\": Retrieve some state.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"set\"}),\": Change some state.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"reset\"}),\": Reset some state to its default value.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"add\"}),\": Add new content to some state.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"remove\"}),\": Delete some existing state.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"apply\"}),\": In-memory replacements\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"compose\"}),\": Create a new dataset from existing information.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"fetch\"}),\":  Retrieve some state from an external data store.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"handle\"}),\": Deal with an action.  Often used in callbacks.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"is/has\"}),\": A pre-verb to denote a boolean.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"$\"}),\": A pre-verb to indicate a JQuery reference.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Duplication\"}),`\n`,(0,n.jsx)(e.p,{children:\"Any named item that is a child should not duplicate its parent name, nor should it repeat any synonym of that patents name. In the following example, we see breakpoints.  We know that breakpoints refer to widths, and as our project is mobile-first, we know they are all minimum widths.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.strong,{children:\"BAD\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-JavaScript\",children:`$breakpoints = {\n  minWidthLg: \\u201C1440px\\u201D,\n  minWidthMd: \\u201C1200px\\u201D,\n  minWidthSm: \\u201C992px\\u201D,\n  minWidthXs: \\u201C768px\\u201D,\n  minWidthXxs: \\u201C500px\\u201D\n};\n`})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.strong,{children:\"GOOD\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-JavaScript\",children:`$breakpoints = {\n    xl: \\u201C1440px\\u201D,\n    lg: \\u201C1200px\\u201D,\n    md: \\u201C992px\\u201D,\n    sm: \\u201C768px\\u201D,\n    xs: \\u201C500px\\u201D\n};\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Classes\"}),`\n`,(0,n.jsx)(e.p,{children:\"Classes must be named with an appropriate proper singular noun in PascalCase, and tell us that this variable contains a type with properties and methods.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-JavaScript\",children:`class Animal { }\nclass Dog extends Animal { }\nclass Dachshunds extends Dog { }\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Class Methods and properties\"}),`\n`,(0,n.jsx)(e.p,{children:\"Class methods and properties use the verb + noun convention, but the methods can get away with omitting the noun in some cases.  In this case, the noun is the parent class.  User.get() assumes you are getting the user User.name assumes a user name.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-JavaScript\",children:`Dog.getName()\nDog.setColor()\nDog.wagTail()\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Numbers, Strings, and Objects\"}),`\n`,(0,n.jsx)(e.p,{children:\"Name all Numbers, strings, and objects with the most appropriate singular noun.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Booleans\"}),`\n`,(0,n.jsx)(e.p,{children:\"The names for booleans are in the form of a question, asking what it is or has or can be.  So our verbs are: is, has, can, or will.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Arrays\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Name arrays with a plural noun, allowing us to address each child as a singular noun.  If need be, you can replace plural with a collection name birds becomes \",(0,n.jsx)(e.strong,{children:\"flockOfBirds\"}),\".\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Functions\"}),`\n`,(0,n.jsx)(e.p,{children:\"Functions are always actions. So we start with a verb then add a noun. Verb + Noun results in a command for a thing.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-JavaScript\",children:`getBirds();\ngoHome()\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Some languages have their own rules around specific types of things (TypeScript prefers interfaces begin with a capital I). I am mostly interested in language-agnostic naming. Do you have any preferences around naming? Bring them up in the comments, and let\\u2019s discuss!\"})]})}function x(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(c,t)})):c(t)}var k=x;return y(A);})();\n;return Component;"
  },
  "_id": "posts/creating-readable-names.mdx",
  "_raw": {
    "sourceFilePath": "posts/creating-readable-names.mdx",
    "sourceFileName": "creating-readable-names.mdx",
    "sourceFileDir": "posts",
    "contentType": "mdx",
    "flattenedPath": "posts/creating-readable-names"
  },
  "type": "Post",
  "slug": "creating-readable-names"
}