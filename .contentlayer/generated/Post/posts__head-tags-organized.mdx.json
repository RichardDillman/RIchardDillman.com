{
  "title": "Head tags organized",
  "date": "2021-01-14T00:00:00.000Z",
  "description": "Order (still) matters  A minimal number of tags are allowed within the HEAD of HTML documents. Those...",
  "tags": [
    "html",
    "performance",
    "javascript",
    "css"
  ],
  "coverImage": "/images/blog/head-tags-organized.jpeg",
  "body": {
    "raw": "\nOrder (still) matters\n\nA minimal number of tags are allowed within the HEAD of HTML documents. Those tags are title, style, base, link, meta, script, and noscript. Oddly enough, these elements’ order can drastically alter the loading of your document and its dependencies. Here are some things I have discovered trying to scratch out better performance within the sites I work on.\n\n## 1: Character Encodings\n\nThe meta tag for the charset declaration should fit entirely within the first 1024 bytes of the file. If the charset is included later in the code, the HTML will be re-parsed once encountered, wasting precious time before rendering anything. So always put it first. The same reasoning applies to the viewport and other meta tags that describe how a page should render.\n\n```HTML\n<meta charset=\"UTF-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n```\n\n## 2: Title Tag\n\nThe title tag’s purpose is to declare the name of the document. It will replace the URL within the browser's tab, so it is good to place it as early as possible to avoid confusion if the user notices when the tab name updates.\n\n```HTML\n<title>Page Title</title>\n```\n\n## 3: Preconnected Links\n\nHere we are focused on third-party domains that we know for sure will be requested. Preconnect will handle the DNS lookup, navigate the connection, and any redirects necessary to reach the targets. It will not download any content. Requesting these connections is particularly helpful on slow connections to establish the route as early as possible. However, this can be costly for mobile devices as multiple connections can consume unnecessary bandwidth.  Only preconnect to servers you are certain will be needed, such as analytics, your CDN, or your static asset site.\n\n```HTML\n<link rel=\"preconnect\" href=\"https://www.google-analytics.com\" />\n```\n\n## 4: Synchronous Scripts\n\nSynchronous scripts include any JavaScript that must run before the page renders, such as populating the dataLayer. Here we include script blocks and external scripts but not deferred or async ones. No matter where it is, any script in the head will block applying CSS, even after the CSS. The browser must process anything that might modify the DOM before processing your styles.  So you should add those synchronous scripts before your style sheet.\n\n```HTML\n<script>...</script>\n<script src=\"app.js\"></script>\n```\n\n## 5: Synchronous CSS\n\nThis includes inline style blocks and style sheets that are used for rendering. Consider using media queries and breaking your styles into multiple files. The media attribute will let the browser know if this CSS is going to be render-blocking or not.\n\nInline styles are parsed first. It is important that we remember that styles are parsed as they are encountered.\n\n```HTML\n<style>...</style>\n```\n\nExternal files are requested and parsed next.\n\n```HTML\n<link href=\"style.css\" rel=\"stylesheet\">\n```\n\nNext to be requested and parsed are the styles with media queries. If they match your current breakpoint, orientation, or pixel density.\n\n```HTML\n<link href=\"other.css\" rel=\"stylesheet\" media=\"(min-width:768px)\">\n```\n\nNext up for request and parsing are the print style sheets.\n\n```HTML\n<link href=\"print.css\" rel=\"stylesheet\" media=\"print\">\n```\n\nStylesheets with media queries that do not match the current environment will not be requested.\n\n```HTML\n<link href=\"other.css\" rel=\"stylesheet\" media=\"(min-width:1024px)\">\n```\n\nKnowing this, you can also trick the browser into loading non-critical CSS a bit later with the onLoad method. By pretending this is a print sheet, it will load after all other CSS but before any containing media queries. Once its load event fires, the media changes to all. With this being async, that will happen after the DOM has been parsed and images begin loading.\n\n```HTML\n<link rel=\"stylesheet\" href=\"lazy.css\" media=\"print\" onload=\"this.media='all'\">\n```\n\n## 6: Preloaded Links\n\nWe should preload as few files as possible. These should be visual elements that are required for above the fold rendering. This includes items like fonts, hero images, or icons.  As for fonts, you most likely only need the woff2 version. Also, consider loading the fonts from your own server.\n\n```HTML\n<link rel=\"preload\" as=\"font\" href=\"font.woff2\" type=\"font/woff2\" />\n```\n\n## 7: Asynchronous or deferred Scripts\n\nAll other scripts[?] requested, such as those that add interaction handlers, go here. We should put these at the bottom of the body to allow for quicker parsing of the DOM. But if you must put them in the head due to CMS or framework restrictions, place them here, and set them to either async or defer depending on your need.\n\n```HTML\n<script src=\"foo.js\" async></script>\n<script src=\"bar.js\" defer></script>\n```\n\n## 8: Prefetched Links\n\nThese are assets that you know for sure you will need later within this page's render cycle. This includes things that you want in place before they are needed. This could include logos in the footer, Twitter feeds, or videos.\n\n```HTML\n<link rel=\"prefetch\" href=\"jwpplayer.js\" />\n```\n\n## 9: Prerendered Links\n\nEntire content pages that you are reasonably certain that your user will visit next. You can download the assets for that page before it is even requested. I would render things like login, search, cart, or the next page in a series.\n\n```HTML\n<link rel=\"prerender\" href=\"/search/\" />\n```\n\n## 10: Non-rendering assets\n\nThis includes meta tags and scripts that do not affect rendering in any way, such as OpenGraph, manifests, structured data. These tags are for bots and sharing in social media but are not necessary to render the page. To include a script in this spot it must be inline as this content will be inspected in the first pass through the document.\n\n```HTML\n<link rel=\"shortcut icon\" href=\"icon.png\" />\n<link rel=\"apple-touch-icon-precomposed\" href=\"icon.png\" />\n<meta name=\"apple-mobile-web-app-title\" content=\"Company Name\" />\n<link rel=\"canonical\" href=\"https://companyname.com\" />\n<meta name=\"twitter:card\" content=\"summary\">\n<meta name=\"twitter:image\" content=\"icon.png\">\n<meta name=\"twitter:description\" content=\"\">\n<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://json-ld.org/contexts/person.jsonld\",\n  \"@id\": \"http://dbpedia.org/resource/John_Lennon\",\n  \"name\": \"John Lennon\",\n  \"born\": \"1940-10-09\",\n  \"spouse\": \"http://dbpedia.org/resource/Cynthia_Lennon\"\n}\n</script>\n```\n\nThose are the most common tags that could be in your head. Do you wonder about any not listed here? Bring them up in the comments, and let’s discuss!\n",
    "code": "var Component=(()=>{var d=Object.create;var i=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var y=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),f=(t,e)=>{for(var r in e)i(t,r,{get:e[r],enumerable:!0})},o=(t,e,r,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of u(e))!g.call(t,s)&&s!==r&&i(t,s,{get:()=>e[s],enumerable:!(a=p(e,s))||a.enumerable});return t};var w=(t,e,r)=>(r=t!=null?d(m(t)):{},o(e||!t||!t.__esModule?i(r,\"default\",{value:t,enumerable:!0}):r,t)),b=t=>o(i({},\"__esModule\",{value:!0}),t);var c=y((v,l)=>{l.exports=_jsx_runtime});var H={};f(H,{default:()=>L,frontmatter:()=>T});var n=w(c()),T={title:\"Head tags organized\",date:\"2021-01-14\",description:\"Order (still) matters  A minimal number of tags are allowed within the HEAD of HTML documents. Those...\",tags:[\"html\",\"performance\",\"javascript\",\"css\"],coverImage:\"/images/blog/head-tags-organized.jpeg\"};function h(t){let e=Object.assign({p:\"p\",h2:\"h2\",pre:\"pre\",code:\"code\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"Order (still) matters\"}),`\n`,(0,n.jsx)(e.p,{children:\"A minimal number of tags are allowed within the HEAD of HTML documents. Those tags are title, style, base, link, meta, script, and noscript. Oddly enough, these elements\\u2019 order can drastically alter the loading of your document and its dependencies. Here are some things I have discovered trying to scratch out better performance within the sites I work on.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"1: Character Encodings\"}),`\n`,(0,n.jsx)(e.p,{children:\"The meta tag for the charset declaration should fit entirely within the first 1024 bytes of the file. If the charset is included later in the code, the HTML will be re-parsed once encountered, wasting precious time before rendering anything. So always put it first. The same reasoning applies to the viewport and other meta tags that describe how a page should render.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-HTML\",children:`<meta charset=\"UTF-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"2: Title Tag\"}),`\n`,(0,n.jsx)(e.p,{children:\"The title tag\\u2019s purpose is to declare the name of the document. It will replace the URL within the browser's tab, so it is good to place it as early as possible to avoid confusion if the user notices when the tab name updates.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-HTML\",children:`<title>Page Title</title>\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"3: Preconnected Links\"}),`\n`,(0,n.jsx)(e.p,{children:\"Here we are focused on third-party domains that we know for sure will be requested. Preconnect will handle the DNS lookup, navigate the connection, and any redirects necessary to reach the targets. It will not download any content. Requesting these connections is particularly helpful on slow connections to establish the route as early as possible. However, this can be costly for mobile devices as multiple connections can consume unnecessary bandwidth.  Only preconnect to servers you are certain will be needed, such as analytics, your CDN, or your static asset site.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-HTML\",children:`<link rel=\"preconnect\" href=\"https://www.google-analytics.com\" />\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"4: Synchronous Scripts\"}),`\n`,(0,n.jsx)(e.p,{children:\"Synchronous scripts include any JavaScript that must run before the page renders, such as populating the dataLayer. Here we include script blocks and external scripts but not deferred or async ones. No matter where it is, any script in the head will block applying CSS, even after the CSS. The browser must process anything that might modify the DOM before processing your styles.  So you should add those synchronous scripts before your style sheet.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-HTML\",children:`<script>...<\\/script>\n<script src=\"app.js\"><\\/script>\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"5: Synchronous CSS\"}),`\n`,(0,n.jsx)(e.p,{children:\"This includes inline style blocks and style sheets that are used for rendering. Consider using media queries and breaking your styles into multiple files. The media attribute will let the browser know if this CSS is going to be render-blocking or not.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Inline styles are parsed first. It is important that we remember that styles are parsed as they are encountered.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-HTML\",children:`<style>...</style>\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"External files are requested and parsed next.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-HTML\",children:`<link href=\"style.css\" rel=\"stylesheet\">\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Next to be requested and parsed are the styles with media queries. If they match your current breakpoint, orientation, or pixel density.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-HTML\",children:`<link href=\"other.css\" rel=\"stylesheet\" media=\"(min-width:768px)\">\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Next up for request and parsing are the print style sheets.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-HTML\",children:`<link href=\"print.css\" rel=\"stylesheet\" media=\"print\">\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Stylesheets with media queries that do not match the current environment will not be requested.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-HTML\",children:`<link href=\"other.css\" rel=\"stylesheet\" media=\"(min-width:1024px)\">\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Knowing this, you can also trick the browser into loading non-critical CSS a bit later with the onLoad method. By pretending this is a print sheet, it will load after all other CSS but before any containing media queries. Once its load event fires, the media changes to all. With this being async, that will happen after the DOM has been parsed and images begin loading.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-HTML\",children:`<link rel=\"stylesheet\" href=\"lazy.css\" media=\"print\" onload=\"this.media='all'\">\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"6: Preloaded Links\"}),`\n`,(0,n.jsx)(e.p,{children:\"We should preload as few files as possible. These should be visual elements that are required for above the fold rendering. This includes items like fonts, hero images, or icons.  As for fonts, you most likely only need the woff2 version. Also, consider loading the fonts from your own server.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-HTML\",children:`<link rel=\"preload\" as=\"font\" href=\"font.woff2\" type=\"font/woff2\" />\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"7: Asynchronous or deferred Scripts\"}),`\n`,(0,n.jsx)(e.p,{children:\"All other scripts[?] requested, such as those that add interaction handlers, go here. We should put these at the bottom of the body to allow for quicker parsing of the DOM. But if you must put them in the head due to CMS or framework restrictions, place them here, and set them to either async or defer depending on your need.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-HTML\",children:`<script src=\"foo.js\" async><\\/script>\n<script src=\"bar.js\" defer><\\/script>\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"8: Prefetched Links\"}),`\n`,(0,n.jsx)(e.p,{children:\"These are assets that you know for sure you will need later within this page's render cycle. This includes things that you want in place before they are needed. This could include logos in the footer, Twitter feeds, or videos.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-HTML\",children:`<link rel=\"prefetch\" href=\"jwpplayer.js\" />\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"9: Prerendered Links\"}),`\n`,(0,n.jsx)(e.p,{children:\"Entire content pages that you are reasonably certain that your user will visit next. You can download the assets for that page before it is even requested. I would render things like login, search, cart, or the next page in a series.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-HTML\",children:`<link rel=\"prerender\" href=\"/search/\" />\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"10: Non-rendering assets\"}),`\n`,(0,n.jsx)(e.p,{children:\"This includes meta tags and scripts that do not affect rendering in any way, such as OpenGraph, manifests, structured data. These tags are for bots and sharing in social media but are not necessary to render the page. To include a script in this spot it must be inline as this content will be inspected in the first pass through the document.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-HTML\",children:`<link rel=\"shortcut icon\" href=\"icon.png\" />\n<link rel=\"apple-touch-icon-precomposed\" href=\"icon.png\" />\n<meta name=\"apple-mobile-web-app-title\" content=\"Company Name\" />\n<link rel=\"canonical\" href=\"https://companyname.com\" />\n<meta name=\"twitter:card\" content=\"summary\">\n<meta name=\"twitter:image\" content=\"icon.png\">\n<meta name=\"twitter:description\" content=\"\">\n<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://json-ld.org/contexts/person.jsonld\",\n  \"@id\": \"http://dbpedia.org/resource/John_Lennon\",\n  \"name\": \"John Lennon\",\n  \"born\": \"1940-10-09\",\n  \"spouse\": \"http://dbpedia.org/resource/Cynthia_Lennon\"\n}\n<\\/script>\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Those are the most common tags that could be in your head. Do you wonder about any not listed here? Bring them up in the comments, and let\\u2019s discuss!\"})]})}function k(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(h,t)})):h(t)}var L=k;return b(H);})();\n;return Component;"
  },
  "_id": "posts/head-tags-organized.mdx",
  "_raw": {
    "sourceFilePath": "posts/head-tags-organized.mdx",
    "sourceFileName": "head-tags-organized.mdx",
    "sourceFileDir": "posts",
    "contentType": "mdx",
    "flattenedPath": "posts/head-tags-organized"
  },
  "type": "Post",
  "slug": "head-tags-organized"
}